// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_remoteclient_service.steamclient.proto

#include "steammessages_remoteclient_service.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
static constexpr ::PROTOBUF_NAMESPACE_ID::Metadata* file_level_metadata_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto = nullptr;
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[2];
const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto::offsets[1] = {};
static constexpr ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema* schemas = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::Message* const* file_default_instances = nullptr;

const char descriptor_table_protodef_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n4steammessages_remoteclient_service.ste"
  "amclient.proto\032 google/protobuf/descript"
  "or.proto\032\030steammessages_base.proto\032,stea"
  "mmessages_unified_base.steamclient.proto"
  "\0321steammessages_remoteclient_service_mes"
  "sages.proto2\312\016\n\014RemoteClient\022\210\001\n\016GetPair"
  "ingInfo\022%.CRemoteClient_GetPairingInfo_R"
  "equest\032&.CRemoteClient_GetPairingInfo_Re"
  "sponse\"\'\202\265\030#Get pairing info for an ente"
  "red PIN\022~\n\014NotifyOnline\022\".CRemoteClient_"
  "Online_Notification\032\013.NoResponse\"=\202\265\0309Le"
  "t the service know we\'re available for s"
  "tatus listeners\022n\n\021NotifyReplyPacket\022\'.C"
  "RemoteClient_ReplyPacket_Notification\032\013."
  "NoResponse\"#\202\265\030\037Send a reply to a remote"
  " client\022\247\001\n\023AllocateRelayServer\022*.CRemot"
  "eClient_AllocateRelayServer_Request\032+.CR"
  "emoteClient_AllocateRelayServer_Response"
  "\"7\202\265\0303Allocate a UDP relay server for a "
  "streaming session\022}\n\013AllocateSDR\022\".CRemo"
  "teClient_AllocateSDR_Request\032#.CRemoteCl"
  "ient_AllocateSDR_Response\"%\202\265\030!Allocate "
  "SDR resources for an app\022\203\001\n\030SendSteamBr"
  "oadcastPacket\022*.CRemoteClient_SteamBroad"
  "cast_Notification\032\013.NoResponse\".\202\265\030*Broa"
  "dcast a packet to remote Steam clients\022{"
  "\n\026SendSteamToSteamPacket\022(.CRemoteClient"
  "_SteamToSteam_Notification\032\013.NoResponse\""
  "*\202\265\030&Send a packet to a remote Steam cli"
  "ent\022\250\001\n\034SendRemotePlaySessionStarted\022#.C"
  "RemotePlay_SessionStarted_Request\032$.CRem"
  "otePlay_SessionStarted_Response\"=\202\265\0309Let"
  " the server know that we started a Remot"
  "e Play session\022\224\001\n\034SendRemotePlaySession"
  "Stopped\022(.CRemotePlay_SessionStopped_Not"
  "ification\032\013.NoResponse\"=\202\265\0309Let the serv"
  "er know that we stopped a Remote Play se"
  "ssion\022\210\001\n\034SendRemotePlayTogetherPacket\022!"
  ".CRemotePlayTogether_Notification\032\013.NoRe"
  "sponse\"8\202\265\0304Send a Remote Play Together "
  "packet to a Steam client\022\311\001\n\"CreateRemot"
  "ePlayTogetherInvitation\0229.CRemoteClient_"
  "CreateRemotePlayTogetherInvitation_Reque"
  "st\032:.CRemoteClient_CreateRemotePlayToget"
  "herInvitation_Response\",\202\265\030(Create a Rem"
  "ote Play Together invitation\022\311\001\n\"DeleteR"
  "emotePlayTogetherInvitation\0229.CRemoteCli"
  "ent_DeleteRemotePlayTogetherInvitation_R"
  "equest\032:.CRemoteClient_DeleteRemotePlayT"
  "ogetherInvitation_Response\",\202\265\030(Delete a"
  " Remote Play Together invitation\032.\202\265\030*Me"
  "thods for Steam remote client operations"
  "2\224\007\n\027RemoteClientSteamClient\022\220\001\n\032NotifyR"
  "egisterStatusUpdate\0220.CRemoteClient_Regi"
  "sterStatusUpdate_Notification\032\013.NoRespon"
  "se\"3\202\265\030/Register for status updates with"
  " a Steam client\022\226\001\n\034NotifyUnregisterStat"
  "usUpdate\0222.CRemoteClient_UnregisterStatu"
  "sUpdate_Notification\032\013.NoResponse\"5\202\265\0301U"
  "nregister for status updates with a Stea"
  "m client\022p\n\022NotifyRemotePacket\022(.CRemote"
  "Client_RemotePacket_Notification\032\013.NoRes"
  "ponse\"#\202\265\030\037Send a packet to a Steam clie"
  "nt\022\205\001\n\032NotifySteamBroadcastPacket\022*.CRem"
  "oteClient_SteamBroadcast_Notification\032\013."
  "NoResponse\".\202\265\030*Broadcast a packet to re"
  "mote Steam clients\022\221\001\n\030NotifySteamToStea"
  "mPacket\022(.CRemoteClient_SteamToSteam_Not"
  "ification\032\013.NoResponse\">\202\265\030:Send a packe"
  "t to a Steam client from a remote Steam "
  "client\022\212\001\n\036NotifyRemotePlayTogetherPacke"
  "t\022!.CRemotePlayTogether_Notification\032\013.N"
  "oResponse\"8\202\265\0304Send a Remote Play Togeth"
  "er packet to a Steam client\0322\202\265\030*Methods"
  " for Steam remote client operations\300\265\030\002B"
  "\035\200\001\001\252\002\027OpenSteamworks.Protobuf"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto_deps[4] = {
  &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5fremoteclient_5fservice_5fmessages_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto = {
  false, false, 3030, descriptor_table_protodef_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto, "steammessages_remoteclient_service.steamclient.proto", 
  &descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto_once, descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto_deps, 4, 0,
  schemas, file_default_instances, TableStruct_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK ::PROTOBUF_NAMESPACE_ID::Metadata
descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto_metadata_getter(int index) {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto);
  return descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto.file_level_metadata[index];
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto(&descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto);

// ===================================================================

RemoteClient::~RemoteClient() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* RemoteClient::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* RemoteClient::GetDescriptor() {
  return descriptor();
}

void RemoteClient::GetPairingInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_GetPairingInfo_Request*,
                         ::CRemoteClient_GetPairingInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetPairingInfo() not implemented.");
  done->Run();
}

void RemoteClient::NotifyOnline(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_Online_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyOnline() not implemented.");
  done->Run();
}

void RemoteClient::NotifyReplyPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_ReplyPacket_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyReplyPacket() not implemented.");
  done->Run();
}

void RemoteClient::AllocateRelayServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_AllocateRelayServer_Request*,
                         ::CRemoteClient_AllocateRelayServer_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method AllocateRelayServer() not implemented.");
  done->Run();
}

void RemoteClient::AllocateSDR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_AllocateSDR_Request*,
                         ::CRemoteClient_AllocateSDR_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method AllocateSDR() not implemented.");
  done->Run();
}

void RemoteClient::SendSteamBroadcastPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_SteamBroadcast_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SendSteamBroadcastPacket() not implemented.");
  done->Run();
}

void RemoteClient::SendSteamToSteamPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_SteamToSteam_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SendSteamToSteamPacket() not implemented.");
  done->Run();
}

void RemoteClient::SendRemotePlaySessionStarted(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemotePlay_SessionStarted_Request*,
                         ::CRemotePlay_SessionStarted_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SendRemotePlaySessionStarted() not implemented.");
  done->Run();
}

void RemoteClient::SendRemotePlaySessionStopped(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemotePlay_SessionStopped_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SendRemotePlaySessionStopped() not implemented.");
  done->Run();
}

void RemoteClient::SendRemotePlayTogetherPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemotePlayTogether_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SendRemotePlayTogetherPacket() not implemented.");
  done->Run();
}

void RemoteClient::CreateRemotePlayTogetherInvitation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_CreateRemotePlayTogetherInvitation_Request*,
                         ::CRemoteClient_CreateRemotePlayTogetherInvitation_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method CreateRemotePlayTogetherInvitation() not implemented.");
  done->Run();
}

void RemoteClient::DeleteRemotePlayTogetherInvitation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Request*,
                         ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method DeleteRemotePlayTogetherInvitation() not implemented.");
  done->Run();
}

void RemoteClient::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      GetPairingInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_GetPairingInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemoteClient_GetPairingInfo_Response*>(
                 response),
             done);
      break;
    case 1:
      NotifyOnline(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_Online_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 2:
      NotifyReplyPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_ReplyPacket_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 3:
      AllocateRelayServer(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_AllocateRelayServer_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemoteClient_AllocateRelayServer_Response*>(
                 response),
             done);
      break;
    case 4:
      AllocateSDR(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_AllocateSDR_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemoteClient_AllocateSDR_Response*>(
                 response),
             done);
      break;
    case 5:
      SendSteamBroadcastPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_SteamBroadcast_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 6:
      SendSteamToSteamPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_SteamToSteam_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 7:
      SendRemotePlaySessionStarted(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemotePlay_SessionStarted_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemotePlay_SessionStarted_Response*>(
                 response),
             done);
      break;
    case 8:
      SendRemotePlaySessionStopped(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemotePlay_SessionStopped_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 9:
      SendRemotePlayTogetherPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemotePlayTogether_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 10:
      CreateRemotePlayTogetherInvitation(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_CreateRemotePlayTogetherInvitation_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemoteClient_CreateRemotePlayTogetherInvitation_Response*>(
                 response),
             done);
      break;
    case 11:
      DeleteRemotePlayTogetherInvitation(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CRemoteClient_DeleteRemotePlayTogetherInvitation_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& RemoteClient::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CRemoteClient_GetPairingInfo_Request::default_instance();
    case 1:
      return ::CRemoteClient_Online_Notification::default_instance();
    case 2:
      return ::CRemoteClient_ReplyPacket_Notification::default_instance();
    case 3:
      return ::CRemoteClient_AllocateRelayServer_Request::default_instance();
    case 4:
      return ::CRemoteClient_AllocateSDR_Request::default_instance();
    case 5:
      return ::CRemoteClient_SteamBroadcast_Notification::default_instance();
    case 6:
      return ::CRemoteClient_SteamToSteam_Notification::default_instance();
    case 7:
      return ::CRemotePlay_SessionStarted_Request::default_instance();
    case 8:
      return ::CRemotePlay_SessionStopped_Notification::default_instance();
    case 9:
      return ::CRemotePlayTogether_Notification::default_instance();
    case 10:
      return ::CRemoteClient_CreateRemotePlayTogetherInvitation_Request::default_instance();
    case 11:
      return ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& RemoteClient::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CRemoteClient_GetPairingInfo_Response::default_instance();
    case 1:
      return ::NoResponse::default_instance();
    case 2:
      return ::NoResponse::default_instance();
    case 3:
      return ::CRemoteClient_AllocateRelayServer_Response::default_instance();
    case 4:
      return ::CRemoteClient_AllocateSDR_Response::default_instance();
    case 5:
      return ::NoResponse::default_instance();
    case 6:
      return ::NoResponse::default_instance();
    case 7:
      return ::CRemotePlay_SessionStarted_Response::default_instance();
    case 8:
      return ::NoResponse::default_instance();
    case 9:
      return ::NoResponse::default_instance();
    case 10:
      return ::CRemoteClient_CreateRemotePlayTogetherInvitation_Response::default_instance();
    case 11:
      return ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

RemoteClient_Stub::RemoteClient_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
RemoteClient_Stub::RemoteClient_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
RemoteClient_Stub::~RemoteClient_Stub() {
  if (owns_channel_) delete channel_;
}

void RemoteClient_Stub::GetPairingInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_GetPairingInfo_Request* request,
                              ::CRemoteClient_GetPairingInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void RemoteClient_Stub::NotifyOnline(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_Online_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void RemoteClient_Stub::NotifyReplyPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_ReplyPacket_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void RemoteClient_Stub::AllocateRelayServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_AllocateRelayServer_Request* request,
                              ::CRemoteClient_AllocateRelayServer_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void RemoteClient_Stub::AllocateSDR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_AllocateSDR_Request* request,
                              ::CRemoteClient_AllocateSDR_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void RemoteClient_Stub::SendSteamBroadcastPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_SteamBroadcast_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void RemoteClient_Stub::SendSteamToSteamPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_SteamToSteam_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}
void RemoteClient_Stub::SendRemotePlaySessionStarted(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemotePlay_SessionStarted_Request* request,
                              ::CRemotePlay_SessionStarted_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(7),
                       controller, request, response, done);
}
void RemoteClient_Stub::SendRemotePlaySessionStopped(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemotePlay_SessionStopped_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(8),
                       controller, request, response, done);
}
void RemoteClient_Stub::SendRemotePlayTogetherPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemotePlayTogether_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(9),
                       controller, request, response, done);
}
void RemoteClient_Stub::CreateRemotePlayTogetherInvitation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_CreateRemotePlayTogetherInvitation_Request* request,
                              ::CRemoteClient_CreateRemotePlayTogetherInvitation_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(10),
                       controller, request, response, done);
}
void RemoteClient_Stub::DeleteRemotePlayTogetherInvitation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Request* request,
                              ::CRemoteClient_DeleteRemotePlayTogetherInvitation_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(11),
                       controller, request, response, done);
}
// ===================================================================

RemoteClientSteamClient::~RemoteClientSteamClient() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* RemoteClientSteamClient::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[1];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* RemoteClientSteamClient::GetDescriptor() {
  return descriptor();
}

void RemoteClientSteamClient::NotifyRegisterStatusUpdate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_RegisterStatusUpdate_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyRegisterStatusUpdate() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::NotifyUnregisterStatusUpdate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_UnregisterStatusUpdate_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyUnregisterStatusUpdate() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::NotifyRemotePacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_RemotePacket_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyRemotePacket() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::NotifySteamBroadcastPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_SteamBroadcast_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifySteamBroadcastPacket() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::NotifySteamToSteamPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemoteClient_SteamToSteam_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifySteamToSteamPacket() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::NotifyRemotePlayTogetherPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CRemotePlayTogether_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method NotifyRemotePlayTogetherPacket() not implemented.");
  done->Run();
}

void RemoteClientSteamClient::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fremoteclient_5fservice_2esteamclient_2eproto[1]);
  switch(method->index()) {
    case 0:
      NotifyRegisterStatusUpdate(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_RegisterStatusUpdate_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 1:
      NotifyUnregisterStatusUpdate(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_UnregisterStatusUpdate_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 2:
      NotifyRemotePacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_RemotePacket_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 3:
      NotifySteamBroadcastPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_SteamBroadcast_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 4:
      NotifySteamToSteamPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemoteClient_SteamToSteam_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 5:
      NotifyRemotePlayTogetherPacket(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CRemotePlayTogether_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& RemoteClientSteamClient::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CRemoteClient_RegisterStatusUpdate_Notification::default_instance();
    case 1:
      return ::CRemoteClient_UnregisterStatusUpdate_Notification::default_instance();
    case 2:
      return ::CRemoteClient_RemotePacket_Notification::default_instance();
    case 3:
      return ::CRemoteClient_SteamBroadcast_Notification::default_instance();
    case 4:
      return ::CRemoteClient_SteamToSteam_Notification::default_instance();
    case 5:
      return ::CRemotePlayTogether_Notification::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& RemoteClientSteamClient::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::NoResponse::default_instance();
    case 1:
      return ::NoResponse::default_instance();
    case 2:
      return ::NoResponse::default_instance();
    case 3:
      return ::NoResponse::default_instance();
    case 4:
      return ::NoResponse::default_instance();
    case 5:
      return ::NoResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

RemoteClientSteamClient_Stub::RemoteClientSteamClient_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
RemoteClientSteamClient_Stub::RemoteClientSteamClient_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
RemoteClientSteamClient_Stub::~RemoteClientSteamClient_Stub() {
  if (owns_channel_) delete channel_;
}

void RemoteClientSteamClient_Stub::NotifyRegisterStatusUpdate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_RegisterStatusUpdate_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void RemoteClientSteamClient_Stub::NotifyUnregisterStatusUpdate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_UnregisterStatusUpdate_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void RemoteClientSteamClient_Stub::NotifyRemotePacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_RemotePacket_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void RemoteClientSteamClient_Stub::NotifySteamBroadcastPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_SteamBroadcast_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void RemoteClientSteamClient_Stub::NotifySteamToSteamPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemoteClient_SteamToSteam_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void RemoteClientSteamClient_Stub::NotifyRemotePlayTogetherPacket(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CRemotePlayTogether_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
